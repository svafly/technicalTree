
CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。

- 技巧二：警惕指针丢失和内存泄漏

  我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。

- 技巧三：利用哨兵简化实现难度

  针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。
- 技巧四：重点留意边界条件处理

  我经常用来检查链表代码是否正确的边界条件有这样几个：
  1. 如果链表为空时，代码是否能正常工作？
  2. 如果链表只包含一个结点时，代码是否能正常工作？
  3. 如果链表只包含两个结点时，代码是否能正常工作？
  4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

- 技巧五：举例画图，辅助思考
- 技巧六：多写多练，没有捷径
  我精选了 5 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。
  1. 单链表反转
  2. 链表中环的检测
  3. 两个有序的链表合并
  4. 删除链表倒数第 n 个结点
  5. 求链表的中间结点
  
leetcode上对应的题目：206，141，21，19，876
